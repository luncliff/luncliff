
goorm COMMIT 행사 발표의 청취노트입니다.

- 구름 기술 블로그 https://tech.goorm.io/commit/
- 구름 COMMIT 세미나 목록 https://tech.goorm.io/category/commit-ko/seminar-ko/

**Comm**unication + **IT**: 기술, 개발, 성장, 조직문화

# 내 동료는 AI입니다: 코딩 위임 1년, 그 과정과 개발 조직의 변화

- https://tech.goorm.io/2509_commit/
- 채널코퍼레이션(Channel Corp.) Lead Web Engineer - 송동욱 님

사내에서 Cursor 도입을 주도.
도입 6개월 이후의 내용을 담은 블로그를 썼는데, 그거 보고 오셨을 듯.

개발한지 5년, 산업기능요원 - 졸업은 아직.
회사에서는 매니징, TF 관리 등등. 그런데 회사+학교는 무리무리
개발을 더 하고 싶은데 시간이 없음. 생산성 슈퍼점프 아니면 안된다. 극한까지 AI를 써보자.

### 당시에는 Cursor + WindSurf

VSCode base라서 손에 익었던 Cursor.
학교과제를 PoC에 사용.

Graphic Canvas Editor 과제를 Cursor로 95% 완성시켜보자. 꽤 유명한 예제.
참고로 쓰기 좋은 과제.

가능성의 발견. 이후 조직차원으로...
- 디자인 패턴 기반의 소통은 깔끔하다
- 책임, 목적 분리가 되어있으니 수정이 쉬움
- 세세한 부분은 집중X. 큰 흐름에 집중 (큰 그림 + 코드 리뷰에 집중)

### 회사 도입

CTO 괴롭히기 (하루 3번!)
보안 점검
멤버들의 AI 친화도(3~4명씩 20회 이상 진행.)
사내 AI문화 사이클(MCP, n8n, MCP 제작, etc)

리더십이 직접 저사용자를 식별하고 활용례 가이드.(많은 노력.)
Cursor, Claude Code에서 Token 많이 쓴 사람은 신경X.
안쓰는 사람, AI포비아 들을 찾아가서 지켜보고, 숙제 내어주고...

AI로 일해본 경험이 처음 - 결과가 잘 나올리가 없다. 공유하는 것이 중요. 굉장히 많은 공유, MCP 사용.

### AI로 코딩하는 방법에 대해서

툴이 많다. Cursor, Codex, Claude Code, etc... 대강 다 비슷하다고 생각하고 걱정 ㄴㄴ
이 세션은 Cursor가 중심.

실전사례 - 가정 1. AI를 적극적으로 쓴다는 것?
- 코딩의 주체를 옮기는 것. 사람이 코드를 작성하는 것에서, 작성하지 않는 것으로 이동(대화 중심)
- 시간이 걸리더라도 연습, 실험이 많이 필요.

Cursor의 사용사례:  
Tab(AI는 보조), Chat(사람이 작성, AI가 일부 지원), Agent(Composer)

가정2. AI는 당신보다 훨씬 코드를 잘 짭니다...
맡겨본 다음, revert하고, 손으로 작성하는 예를 많이 보는데...

알려줘야 기대하는 답변이 나온다. 맥락만 동일하게 주어진다면, AI는 훨씬 잘 작성한다.
- 비즈니스 목표
- 함수형, 개체지향 스타일
- 라이브러리, 패키지
- 예산, man month

### 그래서 우리는(Context Engineering)

AI와 대화,
생각을 풀어내서 체계적으로 정리,
그 과정을 통해 AI가 코드를 작성

AI와의 대화만으로 프로덕트 생성. 위임의 끝판왕.
결과가 틀렸으면 AI의 레버리지를 활용해서 새로 작성하는 것.

Context Engineering
일하려면 맥락이 필요하니, 이것을 위한 엔지니어링 맥락. 추상적이고 포괄적인 느낌이 있음. 엔지니어링 맞나?


| | K-개발자 | AI |
|-----|-----|-----|
| 개발할 줄 아는가? | ? | ok |
| 영어를 잘 하는가? | ? | ok |
| 코드를 잘 작성하는가? | ok | ok |

예시 프롬프트 보여주기.

### 한번에 코드 생성을 막기

예전에는 Ask가 기본값이었지만 이제는 Agent가 기본.
질문에 대해서 응답을 Code로 하는 경향이 있음
- 문제를 먼저 구체화해서 방향을 맞추는 작업을 선행해야 한다.
- 코드 작성은 가장 뒤로 미룬다.(Plan & Act 라던가)

프롬프트 조정: 제품 만들 떄처럼 빡센 프롬프팅은 필요 없지만
기본적인 개념은 알 필요가 있음.

LLM 성능이 향상되면서 양식에는 크게 목맬 필요가 없어졌다. 규격에 맞기만 하면 된다는 느낌.
멀티샷(참고 제공), CoT(Chain of Thought)를 써서 답변 품질을 향상.

주력으로 사용하는 모델에 대해서는 프롬프트 스타일을 알아두면 좋다.

### 기대치 맞추기

기대치를 맞춰야 후환이 적다. 코드 바깥의 맥락을 설명해야 하는데, 한번에 주입하기 매우 어렵다.
생각을 글로 표현하는데 어려움을 겪을수밖에 없다. 반복적인 ping-pong으로 맥락을 숙성하고, 생각을 구체화 한다.

- 왜 고치고 싶은가? (코드를 수정하는 이유가 무엇인지 명확하게)
- 추가 기능 요구사항이 있는건가?
- 성능 문제 때문에 수정?
- 이 코드의 사용처는? 의존성은?
- 코드에 대한 비즈니스 요구 중심의 분석

### Cursor의 indexing기능

코드를 읽어야 하는데... AI는 코드를 어떻게 읽지? Codebase indexing.
코드를 쪼개서 vector DB에 저장, 자연어 쿼리에 맞게 유사도가 높은 코드 조각을 획득, 참조할 코드를 탐색.

명확함의 중요성: 변수명 및 파일명 잘 결정하고, 주석과 [tsdoc](https://github.com/microsoft/tsdoc) 중요. 예전과는 다른 코드 관리 방법.

### 코드 생성을 막았는데...

문제와 작업을 쪼갤 수 있을까?
AI 작성은 **반드시** 사람이 리뷰해야 한다. 책임이 존재함.

리뷰하려면?
- AI 변경을 제어할 수단?
- 작게 변경하고, 직접 확인한다
- Context Window 관리: AI의 작업이 길어지면 기록으로 남겨둔다. (이어서? 아니면 되돌리기?)

이전 대화가 누락되면 세션을 새로 생성한다. Context Window를 잘 제어해야 품질이 관리된다.
Prompt말고 thinking, file content등 context는 금방 소진된다.

세션 토큰이 넘치면? UI 에서 토큰 수 확인. 작업이 길어지면 markdown으로 넘긴다.  
문서를 저장하고(ToDo, Progress 등), 문서가 고도화되면, 토큰 걱정을 덜어준다.

### AI에게 질문 받아보기

1. LLM들은 주어진 것에서 문제를 해결하려는 경향 - 아무튼 Yes
2. 질문을 받아보고, 비판적으로 리뷰 요청(비판을 요구)
   - 코드의 복잡성 수준, 분석에 대해서 context 보충해주겠다는 표현
   - 사례를 요청? 공유? - 의도된 것, 의도하지 않은 것. 답변을 채우는 행위 자체가 추가 맥락이 되므로 긍정적임.

### 디자인 패턴(및 코드베이스의 깔끔함)

정리되지 않은 코드는 LLM이 이해하기 어렵다
간단한 Clean Code 원칙, 디자인 패턴이 정답.  
**사람이 길게 설명할 필요가 줄어든다.**

온보딩으로 디자인 패턴을 사용하기도.

### 답변이 잘 나오면?

리뷰는 어떻게? -> 다이어그램을 요청하자.  
코드 얼개에 대해서 충분히 고민하고, 변경이 필요하면 다시 프롬프팅. 여기서 많은 시간을 투자하는 편.

작업 순서를 상/중/하로 나누고, 리뷰가 된 다이어그램으로 코드 진행 시작. 사소한 부분들이 틀릴수는 있지만 대부분 OK.

- 범위가 명확하므로 예측가능
- 다이어그램이 있으므로 리뷰하기 쉬움

쪼갠 작업의 단위로 commit 생성.

### 정리

많은 정보를 전달할 방법을 찾는다.(가진 정보를 어떻게 잘 조합할 것인가)

공통정보는 저장해서 사용.
언어로 전달하기 어려우면 그때는 index/reference/MCP 사용.

- Before: 1시간 고민 -> 9시간 코딩
- After: 4시간 고민 -> 1시간 코딩

평균 생산성의 요구가 올라가고 있으므로...

### 기타

문서화를 계속 해서 AI에 공급할 자료를 만든다.
- 자주 쓰이는 프롬프트
- 프로젝트 기술 스택
- Tech Spec을 저장소에 통합
- 번역 자동화(제품 context를 고려한 기계번역)
- 팀의 cursorrule을 지속적으로 관리. 코드처럼 다룬다
- 튜토리얼 카드가 중구난방이면, 코드를 보고 리스트업, 트리거 시점하고 컨텐츠를 리포트로 작성.

### 고급 팁

Cursor Rule
- 단계별로 User confirm을 받도록 프롬프팅
- Temp 파일 생성. Temp 파일에 type 있는 언어를 사용해서 error 검출
  - 작업물 내 한글 문장 찾기 -> 한글 문장 기반으로 번역 key-value -> 번역 KV를 한글 문장과 대응 -> 작업물을 KV로 대체 -> MCP로 번역 플랫폼 제출


MCP는 외부 소스를 참조시키기 위한 도구: Context7, Serena, Linear, Sentry, Notion, Obsidian, Figma...
- ex) Manager는 한국에서는 자주 사용하지만... 일본, 미국에서는 잘 맞지 않는 용어임. symbol level의 접근이 필요할 때.

Linear Driven Development
- 맥락을 Ticket, Knowledge System과 연동. 관리가 훨씬 나아졌다.
- 작업 내용을 Ticket으로 생성. 연동은 MCP 적극 활용

**결과물이 Code일 필요도 없다. 시도해보기 나름**

병렬수행 가능. "당신의 뇌가 허락하는 만큼"
(git worktree 명령어를 사용한다던가)

현재 review는 Code Rabbit 사용중.

- 요약, 다이어그램, 메모리 기능 사용 중
- 메모리 기능으로 PR 리뷰 cost를 많이 줄였다

n8n 사용한 배포 자동화. node를 Agent 스럽게.

### 마무리

- 책임은 엔지니어가. 공학자는 문제 해결이 본질이다
- AI는 과정을 도와주는 것이므로, AI 레버리지를 잘 사용하자
